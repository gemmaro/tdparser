# TypeProf 0.21.3

# Classes
module TDParser
  VERSION: String
  FailParser: Class

  def self.xml_token_generator: (untyped src) -> Enumerator[bot, bot]
  def rule: (untyped sym, *untyped opts) -> NonTerminalParser
  def token: (untyped x, ?:=== eqsym) -> TerminalParser
  def backref: (untyped x, ?:=== eqsym) -> BackrefParser
  alias back_ref backref
  def stackref: (untyped stack, ?:=== eqsym) -> StackrefParser
  alias stack_ref stackref
  def state: (untyped s) -> StateParser
  def empty_rule: -> EmptyParser
  alias empty empty_rule
  def any_rule: -> AnyParser
  alias any any_rule
  def none_rule: -> NoneParser
  alias none none_rule
  def fail_rule: -> untyped
  alias fail fail_rule
  def condition_rule: -> ConditionParser
  alias condition condition_rule
  def leftrec: (*untyped rules) -> untyped
  alias left_rec leftrec
  def rightrec: (*untyped rules) -> untyped
  alias right_rec rightrec
  def chainl: (untyped base, *untyped infixes) -> untyped
  alias chain_left chainl
  def chainr: (untyped base, *untyped infixes) -> untyped
  alias chain_right chainr
  def self.define: (*untyped _args) -> untyped

  class Grammar
    include TDParser

    alias define instance_eval
    def respond_to_missing?: -> true
    def method_missing: (:rule | :token sym, *:rule | :token args) -> nil
  end

  class Token
    @kind: untyped
    @value: String

    def initialize: (untyped kind, String value) -> void
    def ===: (untyped other) -> true
  end

  class BasicStringTokenizer
    @rule: untyped
    @scan_pattern: Regexp
    @ignore_pattern: Regexp?

    def self.[]: (untyped rule, ?nil ignore) -> BasicStringTokenizer
    def initialize: (untyped rule, ?Regexp? ignore) -> void
    def generate: (untyped str) -> untyped
  end

  class StringTokenizer < BasicStringTokenizer
    def initialize: (untyped rule, ?nil ignore) -> void
  end

  class XMLArray < Array[untyped]
    def ===: (untyped ary) -> bool
  end

  module XMLParser
    def start_element: (?singleton(String) name) -> untyped
    def end_element: (?singleton(String) name) -> untyped
    def element: (?singleton(String) elem) -> untyped
    def text: (?singleton(String) match) -> untyped
    def pi: -> untyped
    def cdata: (?singleton(String) match) -> untyped
    def comment: (?singleton(String) match) -> untyped
    def xmldecl: -> untyped
    alias xml_decl xmldecl
    def start_doctype: (?singleton(String) name) -> untyped
    def end_doctype: -> untyped
    def doctype: (?singleton(String) name) -> untyped
    def externalentity: (?singleton(String) entity) -> untyped
    alias external_entity externalentity
    def elementdecl: (?singleton(String) elem) -> untyped
    alias element_decl elementdecl
    def entitydecl: (?singleton(String) _entity) -> untyped
    alias entity_decl entitydecl
    def attlistdecl: (?singleton(String) _decl) -> untyped
    alias attribute_list_declaration attlistdecl
    def notationdecl: (?singleton(String) _decl) -> untyped
    alias notation_decl notationdecl
    def any_node: -> untyped
    def dom_constructor: -> untyped
  end

  class TokenGenerator
    @enumerator: Enumerator[bot, bot]
    @buffer: Array[untyped]

    def initialize: (?nil args) -> void
    def next: -> bot
    def to_a: -> Array[untyped]
    def shift: -> nil
    def unshift: (*untyped token) -> Array[untyped]
  end

  class TokenBuffer < Array[untyped]
    attr_accessor map: Hash[untyped, untyped]
    attr_accessor state: untyped
    def initialize: (*untyped args) -> void
    def []: (untyped idx) -> nil
    def []=: (untyped idx, untyped val) -> untyped
    def clear: -> Hash[untyped, untyped]
  end

  class Parser
    include TDParser
    @tokens: false

    def prepare: (TokenBuffer? buff) -> TokenBuffer
    def recover: (TokenBuffer? buff, untyped ts) -> TokenBuffer
    def to_proc: -> ^(*untyped) -> untyped
    def optimize: (?false _default) -> Parser
    def -: (ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser r) -> ConcatParser
    def +: ((ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser)? r) -> ParallelParser
    def |: (untyped r) -> (ActionParser | ChoiceParser | ConcatParser | ParallelParser)
    def *: (untyped range) -> IterationParser
    def >>: (^(Array[untyped]) -> nil act) -> ActionParser
    def /: (untyped label) -> LabelParser
    def %: (untyped stack) -> StackParser
    def >: (untyped symbol) -> Parser
    def ~: -> NegativeParser
    def parse: (?nil tokens, ?nil buff) -> nil
    def peek: -> untyped
  end

  class NonTerminalParser < Parser
    attr_reader context: TDParser
    attr_reader symbol: untyped
    attr_reader options: Array[untyped]
    def initialize: (TDParser context, untyped sym, *untyped options) -> void
    def call: (untyped tokens, untyped buff) -> nil
  end

  class TerminalParser < Parser
    attr_reader symbol: untyped
    attr_reader equality: :===
    def initialize: (untyped obj, :=== eqsym) -> void
    def call: (untyped tokens, untyped buff) -> [untyped]?
  end

  class CompositeParser < Parser
    attr_accessor parsers: Array[(ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser)?]
    def initialize: (*(ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser)? parsers) -> void
    def optimize: (?false default) -> (ActionParser | ChoiceParser | ConcatParser | ParallelParser)
  end

  class ActionParser < CompositeParser
    attr_reader action: ^(Array[untyped]) -> nil
    def initialize: (ConcatParser | Parser parser, ^(Array[untyped]) -> nil act) -> void
    def call: (untyped tokens, TokenBuffer? buff) -> [nil]?
  end

  class LabelParser < CompositeParser
    attr_reader label: untyped
    def initialize: (Parser parser, untyped label) -> void
    def call: (untyped tokens, untyped buff) -> Array[[nil, nil]?]?
  end

  class StackParser < CompositeParser
    attr_reader stack: untyped
    def initialize: (Parser parser, untyped stack) -> void
    def call: (untyped tokens, untyped buff) -> Array[[nil, nil]?]?
  end

  class ConcatParser < CompositeParser
    def call: (untyped tokens, TokenBuffer? buff) -> Array[[nil, nil]?]?
    def -: (ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser r) -> ConcatParser
  end

  class ChoiceParser < CompositeParser
    def call: (untyped tokens, TokenBuffer? buff) -> Array[[nil, nil]?]?
    def optimize: (?bool default) -> (ActionParser | ChoiceParser | ConcatParser | ParallelParser)

    private
    def shared_sequence: ((ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser)? r1, (ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser)? r2) -> ([(ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser)?, (ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser)?, (ActionParser | ChoiceParser | ConcatParser | ParallelParser | Parser)?])
  end

  class ParallelParser < CompositeParser
    def call: (untyped tokens, TokenBuffer? buff) -> [[Array[untyped]?, Array[untyped]?]]
  end

  class IterationParser < CompositeParser
    attr_reader min: untyped
    attr_reader range: nil
    def initialize: (Parser parser, untyped n, nil range) -> void
    def call: (untyped ts, untyped buff) -> [Array[Array[untyped]?]]?
  end

  class NegativeParser < CompositeParser
    def call: (untyped tokens, untyped buff) -> [Array[untyped]]?
  end

  class EmptyParser < Parser
    def call: (untyped _tokens, untyped _buff) -> [nil]
  end

  class AnyParser < Parser
    def call: (untyped tokens, untyped _buff) -> [untyped]?
  end

  class NoneParser < Parser
    def call: (untyped tokens, untyped _buff) -> [nil]?
  end

  class ReferenceParser < Parser
    private
    def backref: (untyped xs, :=== eqsym) -> untyped
  end

  class BackrefParser < ReferenceParser
    attr_reader label: untyped
    attr_reader equality: :===
    def initialize: (untyped label, :=== eqsym) -> void
    def call: (untyped tokens, untyped buff) -> nil
  end

  class StackrefParser < ReferenceParser
    attr_reader stack: untyped
    attr_reader equality: :===
    def initialize: (untyped stack, :=== eqsym) -> void
    def call: (untyped tokens, untyped buff) -> nil
  end

  class ConditionParser < Parser
    attr_reader condition: nil
    def initialize: -> void
    def call: (untyped _tokens, untyped buff) -> [untyped]?
  end

  class StateParser < Parser
    attr_reader state: untyped
    def initialize: (untyped s) -> void
    def call: (untyped _tokens, untyped buff) -> [untyped]?
  end
end
